
Start Presentazione

ZACK %% Provvisorio

Concentriamoci ora su due dei problemi più famosi della dinamica classica
il problema dei tre corpi e il pendolo sferico

il problema dei tre corpi consiste nel calcolare date
la posizione iniziale
la massa
la velocità
di 3 corpi soggetti all'influsso della reciproca attrazione gravitazionale l'evoluzione Futura del sistema da essi costituito
si può pensare di utilizzare un sistema di equazioni differenziali ordinarie derivanti da le leggi del moto di Isaac Newton 
come avviene normalmente in presenza di due corpi

 però si dimostra A differenza del caso di due corpi che non si conoscono soluzioni in forma chiusa 
per cui noi Supponiamo che uno dei tre corpi abbia Massa decisamente superiore a quella degli altri due
In particolare se dovessimo studiare il sistema di tre corpi come Terra Marte e sole  in particolare se dovessimo studiare 
sistema di tre corpi come Terra Marte e il sole dovremmo ricondurci a due situazioni in cui studiamo singolarmente 
l'influsso tra il sole e la Terra e il Sole e Marte
sempre su quel ipotesi che il sole non risente mai dell'attrazione gravitazionale degli altri due corpi contemporaneamente
L'unico modo di approssimare al meglio il moto di tre corpi e quindi utilizzare un metodo numerico

bene, Ora concentriamoci invece su un altro esempio classico ovvero il pendolo sferico
Allora in questo caso Cosa vogliamo fare vogliamo studiare il moto di un . con coordinate X1 X2 X3 
Che nel nostro caso è il centro di massa di un oggetto sferico di peso m soggetto la forza di gravità è 
vincolato a muoversi su una superficie di forma sferica di equazione X 1 quadro X2 quadro X3 quadro meno 1 = 0 
Quindi il seguente sistema di equazioni differenziali ordinarie scritte in forma compatta  descrive le accelerazioni che agiscono su questo. 
Abbiamo indicato con XN punto e i due punti la derivata prima e seconda DX rispetto al tempo T e con h la matrice hessiana di fi

al fine di risolvere numericamente l'equazione riportata nella slide precedente Riportiamo tutto in forma normale quindi 
riscriviamo in una nuova incognita Y un vettore di 6 componenti che saranno poi le variabili di stato del nostro sistema  
per cui le prime tre componenti saranno le nostre tre coordinate spaziali mentre le seconde tre è componenti quindi la 
componente 456 sono le derivate prime delle coordinate spaziali 




SAMUDONZO

I metodi di Runge-Kutta sono metodi a un passo che richiedono differenti valutazioni della funzione f(t,y) in ciascun intervallo di [t_n, t_n+1].
In particolare è possibile esprimere u_n+1 secondo questa formula dove i coeff. bi e il termine Ki  sono le approssimazioni delle derivate della funzione incognita in punti intermedi dell'intervallo di integrazione.


I coefficienti a_ij, bi, ci definiscono 




MICHELE





ROSE






SAMU
Da una parte, si vuole che il passo sia sufficientemente piccolo per garantire un’adeguata precisione; dall’altra, si vuole che sia 
sufficientemente largo da evitare un lavoro computazionale troppo oneroso.
SLIDE 1
La soddisfazione di queste 2 condizioni si sposa perfettamente con la richiesta di rendere il passo adattivo.
Quindi, come implementare un codice\algoritmo che renda il passo adattivo, diminuendo il costo computazionale, ma che comunque 
garantisca una tolleranza dell’errore locale scelta a priori.
Si parta ovviamente dalla scelta di un passo iniziale h, il programma computa le 2 approssimazioni numeriche della soluzione u1 e 
u1 cappello, calcolati dai 2 metodi RK embedded. La differenza tra le approssimazioni dà una buona stima dell’errore locale. 
E ovviamente questa stima, ossia il modulo della differenza delle 2 soluzioni della coppia embedded, deve essere minore uguale della 
tolleranza prescelta. Come si può vedere, la tolleranza può essere formata da un termine di errore assoluto rappresentato dal fattore 
Atol e uno relativo Rtol che invece individua l’errore relativo tra le 2 computazioni tra il passo precedente e quello attuale. 
SLIDE 2	
Prendiamo però come errore locale locale effettivo la norma 2 del rapporto tra la differenza tra le 2 soluzioni numeriche all’iesimo 
passo e la tolleranza imposta. Per rispettare la condizione della slide precedente vogliamo che l’errore sia paragonabile a 1. 
Inoltre l’errore locale si può vedere come una costante C moltiplicata per una potenza q+1 del passo, dove q è il minor ordine tra 
i 2 della coppia embedded, e inoltre noi vogliamo che questo errore sia uguale a 1 per trovare il passo ottimale. 
E vogliamo che C moltiplicato per una potenza q+1 passo ottimale sia comparabile a 1. Si arriva alla formula del passo ottimale che 
è uguale al passo iniziale moltiplicato per il reciproco dell’errore elevato a 1/(q+1).
Se l’errore se minore uguale a 1, la tolleranza è rispettata e la soluzione dell’iesimo passo è accettata. 
Si procede con il calcolo del nuovo passo hnew e si calcolo la soluzione del nuovo step. Se la condizione non è verificata, 
la soluzione non viene accettata e si ripete il calcolo con il nuovo passo hnew.
Per dare robustezza all’algoritmo, vengono introdotti fattori di sicurezza che permettono una maggiore possibilità che la condizione 
della tolleranza sia soddisfatta, e quindi non si continui a ripetere uno step aumentando il costo computazionale,  e inoltre non si 
vuole che il passo cambi bruscamente per ovvi motivi di precisione.







